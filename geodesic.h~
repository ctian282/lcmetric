#ifndef GEODESIC_H
#define GEODESIC_H

#include <cmath>
#include <fstream>
#include <iostream>
#include <iomanip>            
#include <zlib.h>
#include <complex>
#include <vector>
#include "healpix_base.h"
#include "alm_healpix_tools.h"
#include "healpix_map.h"
#include "alm.h"

#include "geodesic_macros.h"

using namespace std::complex_literals;


typedef double real_t;
typedef int idx_t;

typedef std::complex<real_t> cmpx_t;

inline idx_t CHI2CHIBIN(real_t r, real_t dr)
{
  return std::floor ((r) / dr);
}


inline idx_t IDX(idx_t nr, idx_t pix, idx_t NPIX)
{
  return nr*NPIX + pix;
}

struct Photon
{
  idx_t pid;
  pointing pt;
  real_t r;
  real_t Phi, dPhi_dr, dPhi_dtheta, dPhi_dphi, dPhi_ddtheta, dPhi_ddphi, dPhi_dthetadphi,
    dPhi_drdtheta, dPhi_drdphi,
    Omega, dPi_ddr, Phi_ang_lap;

  GEODESIC_APPLY_TO_FIELDS(DECLARE_REAL_T);
  GEODESIC_APPLY_TO_COMPLEX_FIELDS(DECLARE_COMPLEX_T);
};


class _Geodesic
{
  public:

  GEODESIC_APPLY_TO_FIELDS(RK2_FIELDS_ALL_CREATE);
  GEODESIC_APPLY_TO_COMPLEX_FIELDS(RK2_COMPLEX_FIELDS_ALL_CREATE);
  
  real_t * Phi, *Pi, *Omega, *a, *dPi_dr;
  real_t *tars;

  pointing *ang_list;
  
  Healpix_Map <real_t> Phi_s, Pi_s, Omega_s,
    Phi_s_ddr, Phi_s_dtheta, Phi_s_dphi,
    Phi_s_ddtheta, Phi_s_ddphi, Phi_s_dthetadphi, Phi_s_drdtheta, Phi_s_drdphi,
    Phi_s_ang_lap, temp_map;
  Alm< xcomplex< real_t > > temp_lm;
  
  const idx_t NR, NSIDE, NPIX, n_iter, lmax, init_r, final_r;
  
  
  idx_t n_p, n_alm_idx;

  T_Healpix_Base<idx_t> *hp;
  Alm_Base * lm_base;
  idx_t *l_list, *m_list;

  inline real_t to_r(idx_t nr)
  {
    return final_r + (init_r - final_r) * (real_t)nr / NR;
  }

  
  _Geodesic(real_t *Phi_in, real_t *Pi_in, real_t *Omega_in, real_t *dPi_dr_in,
            real_t * a_in, idx_t NR_in, real_t init_r_in, real_t final_r_in,
            idx_t NSIDE_in, idx_t n_iter_in= 30):
    NR(NR_in),
    NSIDE(NSIDE_in),
    NPIX(12*NSIDE*NSIDE),
    n_iter(n_iter_in),
    lmax(2*NSIDE-1),
    init_r(init_r_in),
    final_r(final_r_in),
    Phi(Phi_in),
    Pi(Pi_in),
    dPi_dr(dPi_dr_in),
    Omega(Omega_in),
    a(a_in),
    Phi_s(Healpix_Map<real_t>(NSIDE, Healpix_Ordering_Scheme::RING) ),
    Pi_s(Healpix_Map<real_t>(NSIDE, Healpix_Ordering_Scheme::RING) ),
    Omega_s(Healpix_Map<real_t>(NSIDE, Healpix_Ordering_Scheme::RING) ),
    Phi_s_dtheta(Healpix_Map<real_t>(NSIDE, Healpix_Ordering_Scheme::RING) ),
    Phi_s_dphi(Healpix_Map<real_t>(NSIDE, Healpix_Ordering_Scheme::RING) ),
    temp_map(Healpix_Map<real_t>(NSIDE, Healpix_Ordering_Scheme::RING) ),
    temp_lm(Alm< xcomplex< real_t > >(lmax, lmax) )
  {

    // Healpix instance
    hp = new T_Healpix_Base<idx_t>
      ( NSIDE, Healpix_Ordering_Scheme::RING, SET_NSIDE );

    lm_base = new Alm_Base(lmax, lmax);
    n_alm_idx = lm_base->Num_Alms(lmax, lmax);
    l_list = new idx_t[n_alm_idx];
    m_list = new idx_t[n_alm_idx];
    
    for(int l = 0; l <= lmax; l++)
    {
      for(int m = 0; m <= lmax; m++)
      {
        l_list[lm_base->index(l,m)] = l;
        m_list[lm_base->index(l,m)] = m;
      }
    }
    
    ang_list = new pointing[NPIX];
    for(int i = 0; i < NPIX; i++)
      ang_list[i] = hp->pix2ang(i);
  }
  ~_Geodesic()
  {
    
  }

  // Targets are healpix pixels at distance r
  void init_with_healpix_tar(real_t r)
  {
    n_p = NPIX;
    tars = new real_t [3*n_p];
    for(idx_t i = 0; i < NPIX; i++)
    {
      pointing ang = hp->pix2ang(i);

      real_t x = r * sin(ang.theta) * cos(ang.phi);
      real_t y = r * sin(ang.theta) * sin(ang.phi);
      real_t z = r * cos(ang.theta);
      tars[3*i + 0] = x;
      tars[3*i + 1] = y;
      tars[3*i + 2] = z;
    }

    GEODESIC_APPLY_TO_FIELDS_ARGS(RK2_FIELDS_ALL_INIT, n_p);
    GEODESIC_APPLY_TO_COMPLEX_FIELDS_ARGS(RK2_COMPLEX_FIELDS_ALL_INIT, n_p);
  }


  // 3 things need to be done by this function
  // 1). Extract the healpix array on this shell
  // 2). Convert the alm coeffs of Phi field on this shell
  // 3). Calculating derv1 of Phi field by healpix
  void update_shell_fields(idx_t n)
  {
    for(int i = IDX(n, 0, NPIX); i < IDX(n, 0, NPIX) + NPIX; i++)
    {
      Phi_s[i - IDX(n, 0, NPIX)] = Phi[i];
      Pi_s[i - IDX(n, 0, NPIX)] = Pi[i];
      Phi_s_ddr[i - IDX(n, 0, NPIX)] = dPi_dr[i];
    }
    // Calculating first derivatives
    map2alm_iter(Phi_s, temp_lm, n_iter);
    alm2map_der1(temp_lm, temp_map, Phi_s_dtheta, Phi_s_dphi);
    for(idx_t i = 0; i < NPIX; i++)
      Phi_s_dphi[i] *= sin(ang_list[i].theta);

    // Calculating lap
    for(idx_t i = 0; i < n_alm_idx; i++)
    {
      temp_lm *= -l[i] * (l[i]+1);
    }
    alm2map(temp_lm, Phi_s_ang_lap);

    // Calculating second and mixing derivatives
    map2alm_iter(Phi_s_dtheta, temp_lm, n_iter);
    alm2map_der1(temp_lm, temp_map, Phi_s_ddtheta, Phi_s_dthetadphi);

    map2alm_iter(Pi_s, temp_lm, n_iter);
    alm2map_der1(temp_lm, temp_map, Phi_s_drdtheta, Phi_s_drdphi);
    for(idx_t i = 0; i < NPIX; i++)
      Phi_s_drdphi[i] *= sin(ang_list[i].theta);

    
    
    // Calculating second and mixing derivatives
    map2alm_iter(Phi_s_dphi, temp_lm, n_iter);
    alm2map_der1(temp_lm, temp_map, Phi_s_dthetadphi, Phi_s_ddphi);
    for(idx_t i = 0; i < NPIX; i++)
      Phi_s_ddphi[i] *= sin(ang_list[i].theta);

  }

  
  /**********************RHS of geodesics***************/

  real_t dtheta_dt(Photon &p)
  {
    return (1.0 + 2.0 * p.Phi ) * p.ntheta;
  }

  real_t dphi_dt(Photon &p)
  {
    return (1.0 + 2.0 * p.Phi ) * p.nphi;
  }

  real_t dk0_dt(Photon &p)
  {
    return -4.0 * (p.Pi + p.ntheta * p.dPhi_dtheta + p.nphi * p.dPhi_dphi)
      - 2.0 * (p.Omega + p.Pi);
  }

  real_t dntheta_dt(Photon &p)
  {
    return 2.0 * p.ntheta * ( 1.0 * p.Pi, p.ntheta * p.dPhi_dtheta + p.nphi * p.dPhi_dphi)
      - 2.0 * (p.dPhi_dtheta / PW2(p.r)  );
  }

  real_t dnphi_dt(Photon &p)
  {
    return 2.0 * p.nphi * ( 1.0 * p.Pi, p.ntheta * p.dPhi_dtheta + p.nphi * p.dPhi_dphi)
      - 2.0 * (p.dPhi_dphi / PW2(p.r * sin(p.pt.theta)))

  }
  
  real_t dDA_dt(Photon &p)
  {
    return p.dDAdt;
  }

  real_t ddDAdt_dt(Photon &p)
  {
    return - dk0_dt(p) * p.dDAdt
      + 1.0 * (1 + 2 * p.Phi) *
      (p.nr * p.nr * p.dPhi_ddr + 2.0 * p.nr * p.ntheta * p.dPhi_drdtheta + 2.0 * p.nr * p.nphi * p.dPhi_dr_dphi
      + p.ntheta * p.ntheta * p.dPhi_ddtheta + 2.0 * p.ntheta * p.nphi * p.dPhi_dthetadphi
      + p.nphi * p.nphi * p.dPhi_ddphi
      - p.Phi_lap ) ;
  }


  real_t de1r_dt(Photon &p)
  {
    return p.nr * 2.0 *
      (p.e1r * p.dPhi_dr + p.e1theta * p.dPhi_dtheta + p.e1phi * p.dPhi_dphi);
  }
  real_t de1theta_dt(Photon &p)
  {
    return p.ntheta * 2.0 *
      (p.e1r * p.dPhi_dr + p.e1theta * p.dPhi_dtheta + p.e1phi * p.dPhi_dphi);
  }
  real_t de1phi_dt(Photon &p)
  {
    return p.nphi * 2.0 *
      (p.e1r * p.dPhi_dr + p.e1theta * p.dPhi_dtheta + p.e1phi * p.dPhi_dphi);
  }

  real_t de2r_dt(Photon &p)
  {
    return p.nr * 2.0 *
      (p.e1r * p.dPhi_dr + p.e1theta * p.dPhi_dtheta + p.e1phi * p.dPhi_dphi);
  }
  real_t de2theta_dt(Photon &p)
  {
    return p.ntheta * 2.0 *
      (p.e1r * p.dPhi_dr + p.e1theta * p.dPhi_dtheta + p.e1phi * p.dPhi_dphi);
  }
  real_t de2phi_dt(Photon &p)
  {
    return p.nphi * 2.0 *
      (p.e1r * p.dPhi_dr + p.e1theta * p.dPhi_dtheta + p.e1phi * p.dPhi_dphi);
  }

  
  real_t dbeta1_dt(Photon &p)
  {
    return 2.0 * p.beta1 * (p.Omega + p.dPhi_dr)
      - (1 + 2 * p.Phi) * p.a *
      (p.e1r * p.dPhi_dr + p.e1theta * p.dPhi_dtheta + p.e1phi * p.dPhi_dphi);
  }

  real_t dbeta2_dt(Photon &p)
  {
    return 2.0 * p.beta2 * (p.Omega + p.dPhi_dr)
      - (1 + 2 * p.Phi) * p.a *
      (p.e2r * p.dPhi_dr + p.e2theta * p.dPhi_dtheta + p.e2phi * p.dPhi_dphi);
  }

  cmpx_t dsigma_dt(Photon &p)
  {
    return - dk0_dt(p) * p.sigma + 0.5 * PW2(p.DA) * (1.0 + 2.0 * p.Phi)
      * (+ (p.e1r * p.e1r - p.e2r * p.e2r + 1i * p.e1r * p.e2r + 1i * p.e2r * p.e1r )
         * p.dPhi_ddr
         + (p.e1r * p.e1theta - p.e2r * p.e2theta + 1i * p.e1r * p.e2theta + 1i * p.e2r * p.e1theta )
         * 2.0 * p.dPhi_drdtheta
         + (p.e1r * p.e1phi - p.e2r * p.e2phi + 1i * p.e1r * p.e2phi + 1i * p.e2r * p.e1phi )
         * 2.0 * p.dPhi_drdphi
         + (p.e1theta * p.e1theta - p.e2theta * p.e2theta + 1i * p.e1theta * p.e2theta + 1i * p.e2theta * p.e1theta )
         * p.dPhi_ddtheta
         + (p.e1theta * p.e1phi - p.e2theta * p.e2phi + 1i * p.e1theta * p.e2phi + 1i * p.e2theta * p.e1phi )
         * 2.0 * p.dPhi_dthetadphi
         + (p.e1phi * p.e1phi - p.e2phi * p.e2phi + 1i * p.e1phi * p.e2phi + 1i * p.e2phi * p.e1phi )
         *  p.dPhi_dthetadphi         
      )
  }

  cmpx_t depsilon_dt(Photon *p)
  {
    return 0.0;
  }

  cmpx_t domega_dt(Photon *p)
  {
    return 0.0;
  }

  
  /****************************************************/

  void set_photon_values(Photon &p, idx_t n)
  {
    GEODESIC_APPLY_TO_FIELDS(SET_LOCAL_VALUES);
    GEODESIC_APPLY_TO_COMPLEX_FIELDS(SET_LOCAL_VALUES);

    p.r = to_r(n);
    
    p.pt = pointing(p.theta, p.phi);
    p.Phi = Phi_s.interpolated_value(p.pt);
    p.dPhi_dr = Pi_s.interpolated_value(p.pt);
    p.dPhi_dtheta = Phi_s_dtheta.interpolated_value(p.pt);
    p.dPhi_dphi = Phi_s_dphi.interpolated_value(p.pt);

    // Ordinary derivatives
    p.dPhi_ddr = Phi_s_ddr.interpolated_value(p.pt);
    p.dPhi_drdtheta = Phi_s_drdtheta.interpolated_value(p.pt);
    p.dPhi_drdphi = Phi_s_drdphi.interpolated_value(p.pt);
    p.dPhi_ddphi = Phi_s_ddphi.interpolated_value(p.pt);
    p.dPhi_ddtheta = Phi_s_ddtheta.interpolated_value(p.pt);
    p.dPhi_dthetadphi = Phi_s_dthetadphi.interpolated_value(p.pt);

    p.Phi_lap = Phi_s_ang_lap.interpolated_value(p.pt) / PW2(p.r)
      + (2 * p.dPhi_dr + p.r * p.dPhiddr) / p.r ;
    
    // Adding connection terms
    p.dPhi_ddr += 0;
    p.dPhi_drdtheta += p.dPHi_dtheta / p.r;
    p.dPhi_drdphi += p.dPhi_dphi / p.r;
    p.dPhi_ddtheta += -p.r * p.dPhi_dr;
    p.dPhi_dthetadphi += p.dPhi_dphi / tan(p.pt.theta);
    p.dPhi_ddphi += -p.r * PW2(sin(p.pt.theta)) * p.dPhi_dr - cos(p.pt.theta) * sin(p.pt.theta) * p.dPhi_dtheta;
      
  }
  
  // rk2 advance from n to n+1
  void time_advance(idx_t n)
  {
    update_shell_fields(n);

    for(int i = 0; i < n_p; i++)
    {
      Photon p;
      set_photon_values(p, n);
      
    }
  }


  
};


#endif
